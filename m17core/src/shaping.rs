pub static RRC_48K: [f32; 81] = [
    -0.0031955054,
    -0.002930098,
    -0.001940547,
    -0.00035607078,
    0.0015469185,
    0.003389342,
    0.0047616027,
    0.0053105336,
    0.0048244493,
    0.003297721,
    0.00095865194,
    -0.0017498062,
    -0.00423843,
    -0.005881418,
    -0.006149877,
    -0.0047450834,
    -0.0017040828,
    0.0025476913,
    0.0072151264,
    0.011230345,
    0.013421123,
    0.012729687,
    0.008449026,
    0.00043672565,
    -0.010734711,
    -0.023725418,
    -0.03649577,
    -0.04649801,
    -0.0509759,
    -0.04733776,
    -0.03355284,
    -0.008513286,
    0.027694825,
    0.07365995,
    0.1266812,
    0.18297966,
    0.23806532,
    0.28721792,
    0.3260201,
    0.35087407,
    0.35943073,
    0.35087407,
    0.3260201,
    0.28721792,
    0.23806532,
    0.18297966,
    0.1266812,
    0.07365995,
    0.027694825,
    -0.008513286,
    -0.03355284,
    -0.04733776,
    -0.0509759,
    -0.04649801,
    -0.03649577,
    -0.023725418,
    -0.010734711,
    0.00043672565,
    0.008449026,
    0.012729687,
    0.013421123,
    0.011230345,
    0.0072151264,
    0.0025476913,
    -0.0017040828,
    -0.0047450834,
    -0.006149877,
    -0.005881418,
    -0.00423843,
    -0.0017498062,
    0.00095865194,
    0.003297721,
    0.0048244493,
    0.0053105336,
    0.0047616027,
    0.003389342,
    0.0015469185,
    -0.00035607078,
    -0.001940547,
    -0.002930098,
    -0.0031955054,
];

#[cfg(test)]
mod test {
    use std::f32::consts::PI;

    #[test]
    fn calculate_rrc_coefficients() {
        let mut rrc = [0.0; 81];
        let roll_off = 0.5;
        let t_s: f32 = 10.0;

        let inf_t = t_s / (4.0 * roll_off);

        for i in 0..81 {
            let t = (i as isize - 40) as f32;

            if t == 0.0 {
                rrc[i] = 1.0 / t_s.sqrt() * ((1.0 - roll_off) + (4.0 * roll_off / PI));
            } else if t == inf_t || t == -inf_t {
                rrc[i] = roll_off / (2.0 * t_s).sqrt()
                    * ((1.0 + 2.0 / PI) * f32::sin(PI / (4.0 * roll_off))
                        + (1.0 - 2.0 / PI) * f32::cos(PI / (4.0 * roll_off)));
            } else {
                rrc[i] = 1.0 / t_s.sqrt()
                    * (f32::sin((PI * t * (1.0 - roll_off)) / t_s)
                        + (4.0 * roll_off * t) / t_s * f32::cos((PI * t * (1.0 + roll_off)) / t_s))
                    / (PI * t / t_s * (1.0 - (4.0 * roll_off * t / t_s).powi(2)));
            }
        }

        println!("{:?}", rrc);
        for (a, b) in rrc.iter().zip(super::RRC_48K.iter()) {
            assert!((a - b).abs() < 0.00001);
        }
    }
}
